{"version":3,"sources":["../../src/cascader/cascader.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AAGlE,OAAO,EAAE,eAAe,EAAE,MAAM,QAAQ,CAAC;AAMzC,MAAM,WAAW,aAAc,SAAQ,eAAe;CAAG;AAMzD,MAAM,CAAC,OAAO,OAAO,QAAS,SAAQ,cAAc;IAClD,eAAe,WAAuB;IAEtC,OAAO,EAAE,iBAAiB,CAAC,SAAS,CAAC,gBAAgB,CAEnD;IAEF,UAAU,6DAAS;IAEnB,IAAI;;;;;;;;;MASF;IAEF,SAAS;;;;;MAkDP;IAEF,OAAO;;;;;;;;MAmFL;CACH","file":"cascader.d.ts","sourcesContent":["import { SuperComponent, wxComponent } from '../common/src/index';\nimport config from '../common/config';\nimport props from './props';\nimport { TdCascaderProps } from './type';\nimport { getRect } from '../common/utils';\n\nconst { prefix } = config;\nconst name = `${prefix}-cascader`;\n\nexport interface CascaderProps extends TdCascaderProps {}\n\ntype OptionsType = TdCascaderProps['options']['value'];\n\nconst defaultOptionLabel = '选择选项';\n@wxComponent()\nexport default class Cascader extends SuperComponent {\n  externalClasses = [`${prefix}-class`];\n\n  options: WechatMiniprogram.Component.ComponentOptions = {\n    multipleSlots: true,\n  };\n\n  properties = props;\n\n  data = {\n    prefix,\n    name,\n    stepIndex: 0,\n    selectedIndexes: [],\n    selectedValue: [],\n    defaultOptionLabel,\n    scrollTopList: [],\n    steps: [defaultOptionLabel],\n  };\n\n  observers = {\n    visible(v) {\n      if (v) {\n        const $tabs = this.selectComponent('#tabs');\n\n        $tabs?.setTrack();\n        this.updateScrollTop();\n      }\n    },\n    'value, options'() {\n      this.initWithValue();\n    },\n    'selectedIndexes, options'() {\n      const { options, selectedIndexes, keys } = this.data;\n      const selectedValue = [];\n      const steps = [];\n      const items = [options];\n\n      if (options.length > 0) {\n        for (let i = 0, size = selectedIndexes.length; i < size; i += 1) {\n          const index = selectedIndexes[i];\n          const next = items[i][index];\n\n          selectedValue.push(next[keys?.value ?? 'value']);\n          steps.push(next[keys?.label ?? 'label']);\n\n          if (next[keys?.children ?? 'children']) {\n            items.push(next[keys?.children ?? 'children']);\n          }\n        }\n      }\n\n      if (steps.length < items.length) {\n        steps.push(defaultOptionLabel);\n      }\n\n      this.setData({\n        steps,\n        items,\n        selectedValue,\n        stepIndex: items.length - 1,\n      });\n    },\n    async stepIndex() {\n      const { visible } = this.data;\n\n      if (visible) {\n        this.updateScrollTop();\n      }\n    },\n  };\n\n  methods = {\n    initWithValue() {\n      if (this.data.value != null) {\n        const selectedIndexes = this.getIndexesByValue(this.data.options, this.data.value);\n\n        if (selectedIndexes) {\n          this.setData({ selectedIndexes });\n        }\n      }\n    },\n    getIndexesByValue(options: OptionsType, value) {\n      const { keys } = this.data;\n\n      for (let i = 0, size = options.length; i < size; i += 1) {\n        const opt = options[i];\n        if (opt[keys?.value ?? 'value'] === value) {\n          return [i];\n        }\n        if (opt[keys?.children ?? 'children']) {\n          const res = this.getIndexesByValue(opt[keys?.children ?? 'children'], value);\n          if (res) {\n            return [i, ...res];\n          }\n        }\n      }\n    },\n    updateScrollTop() {\n      const { visible, items, selectedIndexes, stepIndex } = this.data;\n\n      if (visible) {\n        getRect(this, '.cascader-radio-group-0').then((rect) => {\n          const eachRadioHeight = rect.height / items[0]?.length;\n\n          this.setData({\n            [`scrollTopList[${stepIndex}]`]: eachRadioHeight * selectedIndexes[stepIndex],\n          });\n        });\n      }\n    },\n    hide() {\n      this.setData({ visible: false });\n    },\n    onStepClick(e) {\n      const { index } = e.currentTarget.dataset;\n\n      this.setData({ stepIndex: index });\n    },\n    onTabChange(e) {\n      const { value } = e.detail;\n\n      this.setData({\n        stepIndex: value,\n      });\n    },\n    handleSelect(e) {\n      const { level } = e.target.dataset;\n      const { value } = e.detail;\n      const { selectedIndexes, items, keys } = this.data;\n      const index = items[level].findIndex((item) => item[keys?.value ?? 'value'] === value);\n      const item = items[level][index];\n\n      if (item.disabled) {\n        return;\n      }\n      selectedIndexes[level] = index;\n      selectedIndexes.length = level + 1;\n\n      this.triggerEvent('pick', item[keys?.value ?? 'value'], index);\n\n      if (item?.[keys?.children ?? 'children']?.length) {\n        this.setData({ selectedIndexes });\n      } else {\n        // setCascaderValue(item.value);\n        this.setData({ selectedIndexes }, () => {\n          const { items } = this.data;\n          this.triggerEvent('change', {\n            value: item[keys?.value ?? 'value'],\n            selectedOptions: items.map((item, index) => item[selectedIndexes[index]]),\n          });\n        });\n        this.hide();\n      }\n    },\n  };\n}\n"]}