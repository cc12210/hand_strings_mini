{"version":3,"sources":["../../src/message/message.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,cAAc,EAAe,qBAAqB,EAAE,MAAM,qBAAqB,CAAC;AAEzF,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AAUnD,MAAM,CAAC,OAAO,OAAO,OAAQ,SAAQ,cAAc;IACjD,eAAe,WAMb;IAEF,OAAO,EAAE,qBAAqB,CAG5B;IAGF,UAAU,EAAE,YAAY,CAA2C;IAGnE,IAAI;;;;;;;MAOF;IAEF,SAAS;;;;MAwBP;IAEF,aAAa;IACb,mBAAmB,SAAK;IAExB,WAAW;IACX,oBAAoB,SAAK;IAEzB,cAAc,8BAGX;IAEH,KAAK;IAIL,gBAAgB;IAChB,cAAc;IAOd,SAAS,CAAC,EAAE,EAAE,MAAM,IAAI;IAIxB,QAAQ;IAIR,uBAAuB;IACvB,cAAc;IAiDd,aAAa;IACb,qBAAqB;IAKrB,IAAI;IA2BJ,IAAI;IAgBJ,KAAK;IAQL,WAAW;IAKX,cAAc;CAGf","file":"message.d.ts","sourcesContent":["import { SuperComponent, wxComponent, ComponentsOptionsType } from '../common/src/index';\nimport config from '../common/config';\nimport { MessageProps } from './message.interface';\nimport props from './props';\nimport { getRect, unitConvert, calcIcon } from '../common/utils';\n\nconst { prefix } = config;\nconst name = `${prefix}-message`;\n\n// 展示动画持续时间\nconst SHOW_DURATION = 500;\n@wxComponent()\nexport default class Message extends SuperComponent {\n  externalClasses = [\n    `${prefix}-class`,\n    `${prefix}-class-content`,\n    `${prefix}-class-icon`,\n    `${prefix}-class-action`,\n    `${prefix}-class-close-btn`,\n  ];\n\n  options: ComponentsOptionsType = {\n    styleIsolation: 'apply-shared',\n    multipleSlots: true,\n  };\n\n  // 组件的对外属性\n  properties: MessageProps = { ...props } as unknown as MessageProps;\n\n  // 组件的内部数据\n  data = {\n    prefix,\n    classPrefix: name,\n    loop: -1,\n    animation: [],\n    showAnimation: [],\n    wrapTop: -999, // 初始定位，保证在可视区域外。\n  };\n\n  observers = {\n    marquee(val) {\n      if (JSON.stringify(val) === '{}') {\n        this.setData({\n          marquee: {\n            speed: 50,\n            loop: -1,\n            delay: 5000,\n          },\n        });\n      }\n    },\n\n    icon(v) {\n      this.setData({\n        _icon: calcIcon(v, 'error-circle-filled'),\n      });\n    },\n\n    closeBtn(v) {\n      this.setData({\n        _closeBtn: calcIcon(v, 'close'),\n      });\n    },\n  };\n\n  /** 延时关闭句柄 */\n  closeTimeoutContext = 0;\n\n  /** 动画句柄 */\n  nextAnimationContext = 0;\n\n  resetAnimation = wx.createAnimation({\n    duration: 0,\n    timingFunction: 'linear',\n  });\n\n  ready() {\n    this.memoInitalData();\n  }\n\n  /** 记录组件设置的项目 */\n  memoInitalData() {\n    this.initalData = {\n      ...this.properties,\n      ...this.data,\n    };\n  }\n\n  resetData(cb: () => void) {\n    this.setData({ ...this.initalData }, cb);\n  }\n\n  detached() {\n    this.clearMessageAnimation();\n  }\n\n  /** 检查是否需要开启一个新的动画循环 */\n  checkAnimation() {\n    if (!this.properties.marquee) {\n      return;\n    }\n\n    const speeding = this.properties.marquee.speed;\n\n    if (this.data.loop > 0) {\n      this.data.loop -= 1;\n    } else if (this.data.loop === 0) {\n      // 动画回到初始位置\n      this.setData({ animation: this.resetAnimation.translateX(0).step().export() });\n      return;\n    }\n\n    if (this.nextAnimationContext) {\n      this.clearMessageAnimation();\n    }\n\n    const warpID = `#${name}__text-wrap`;\n    const nodeID = `#${name}__text`;\n    Promise.all([getRect(this, nodeID), getRect(this, warpID)]).then(([nodeRect, wrapRect]) => {\n      this.setData(\n        {\n          animation: this.resetAnimation.translateX(wrapRect.width).step().export(),\n        },\n        () => {\n          const durationTime = ((nodeRect.width + wrapRect.width) / speeding) * 1000;\n          const nextAnimation = wx\n            .createAnimation({\n              // 默认50px/s\n              duration: durationTime,\n            })\n            .translateX(-nodeRect.width)\n            .step()\n            .export();\n\n          // 这里就只能用 setTimeout/20, nextTick 没用\n          // 不用这个的话会出现reset动画没跑完就开始跑这个等的奇怪问题\n          setTimeout(() => {\n            this.nextAnimationContext = setTimeout(this.checkAnimation.bind(this), durationTime) as unknown as number;\n\n            this.setData({ animation: nextAnimation });\n          }, 20);\n        },\n      );\n    });\n  }\n\n  /** 清理动画循环 */\n  clearMessageAnimation() {\n    clearTimeout(this.nextAnimationContext);\n    this.nextAnimationContext = 0;\n  }\n\n  show() {\n    const { duration, marquee, offset } = this.properties;\n    this.setData({ visible: true, loop: marquee.loop });\n    this.reset();\n    this.checkAnimation();\n    if (duration && duration > 0) {\n      this.closeTimeoutContext = setTimeout(() => {\n        this.hide();\n        this.triggerEvent('durationEnd', { self: this });\n      }, duration) as unknown as number;\n    }\n\n    const wrapID = `#${name}`;\n    getRect(this, wrapID).then((wrapRect) => {\n      // 入场动画。先根据 message 的实际高度设置绝对定位的 top 值，再开始显示动画\n      this.setData({ wrapTop: -wrapRect.height }, () => {\n        this.setData({\n          showAnimation: wx\n            .createAnimation({ duration: SHOW_DURATION, timingFunction: 'ease' })\n            .translateY(wrapRect.height + unitConvert(offset[0]))\n            .step()\n            .export(),\n        });\n      });\n    });\n  }\n\n  hide() {\n    this.reset();\n    this.setData({\n      // 出场动画\n      showAnimation: wx\n        .createAnimation({ duration: SHOW_DURATION, timingFunction: 'ease' })\n        .translateY(this.data.wrapTop)\n        .step()\n        .export(),\n    });\n    setTimeout(() => {\n      this.setData({ visible: false, animation: [] });\n    }, SHOW_DURATION);\n  }\n\n  // 重置定时器\n  reset() {\n    if (this.nextAnimationContext) {\n      this.clearMessageAnimation();\n    }\n    clearTimeout(this.closeTimeoutContext);\n    this.closeTimeoutContext = 0;\n  }\n\n  handleClose() {\n    this.hide();\n    this.triggerEvent('closeBtnClick');\n  }\n\n  handleBtnClick() {\n    this.triggerEvent('actionBtnClick', { self: this });\n  }\n}\n"]}