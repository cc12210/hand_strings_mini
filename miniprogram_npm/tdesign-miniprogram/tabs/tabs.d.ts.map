{"version":3,"sources":["../../src/tabs/tabs.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAe,gBAAgB,EAAE,MAAM,qBAAqB,CAAC;AAKpF,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAMrC,MAAM,WAAW,SAAU,SAAQ,WAAW;CAAG;AAGjD,MAAM,CAAC,OAAO,OAAO,IAAK,SAAQ,cAAc;IAC9C,SAAS,WAAW;IAEpB,eAAe,WAAkG;IAEjH,SAAS,EAAE,gBAAgB,CAezB;IAEF,UAAU,cAAS;IAEnB,eAAe;;;QAKb;IAEF,SAAS;;MAMP;IAEF,IAAI;;;;;;;;;;;MAWF;IAEF,SAAS;;;MAgBP;IAEF,WAAW;IAMX,OAAO;;;+BAuBkB,MAAM;;yCAwBI,MAAM,cAAc,MAAM,eAAe,MAAM,UAAU,MAAM;;;wBAoEhF,GAAG;4BAMC,GAAG;2BAMJ,GAAG;;6BAmBD,6BAA6B;;qCAarB,MAAM;MAYnC;CACH","file":"tabs.d.ts","sourcesContent":["import { SuperComponent, wxComponent, RelationsOptions } from '../common/src/index';\nimport props from './props';\nimport config from '../common/config';\nimport touch from '../mixins/touch';\nimport { getRect, uniqueFactory } from '../common/utils';\nimport { TdTabsProps } from './type';\n\nconst { prefix } = config;\nconst name = `${prefix}-tabs`;\nconst getUniqueID = uniqueFactory('tabs');\n\nexport interface TabsProps extends TdTabsProps {}\n\n@wxComponent()\nexport default class Tabs extends SuperComponent {\n  behaviors = [touch];\n\n  externalClasses = [`${prefix}-class`, `${prefix}-class-item`, `${prefix}-class-active`, `${prefix}-class-track`];\n\n  relations: RelationsOptions = {\n    '../tab-panel/tab-panel': {\n      type: 'descendant',\n      linked(target: any) {\n        this.children.push(target);\n        this.initChildId();\n        target.index = this.children.length - 1;\n        this.updateTabs();\n      },\n      unlinked(target: WechatMiniprogram.Component.TrivialInstance) {\n        this.children = this.children.filter((item) => item.index !== target.index);\n        this.updateTabs(() => this.setTrack());\n        this.initChildId();\n      },\n    },\n  };\n\n  properties = props;\n\n  controlledProps = [\n    {\n      key: 'value',\n      event: 'change',\n    },\n  ];\n\n  observers = {\n    value(name) {\n      if (name !== this.getCurrentName()) {\n        this.setCurrentIndexByName(name);\n      }\n    },\n  };\n\n  data = {\n    prefix,\n    classPrefix: name,\n    tabs: [],\n    currentIndex: -1,\n    trackStyle: '',\n    isScrollX: true,\n    direction: 'X',\n    offset: 0,\n    tabID: '',\n    placement: 'top',\n  };\n\n  lifetimes = {\n    created() {\n      this.children = this.children || [];\n    },\n\n    attached() {\n      wx.nextTick(() => {\n        this.setTrack();\n      });\n      getRect(this, `.${name}`).then((rect) => {\n        this.containerWidth = rect.width;\n      });\n      this.setData({\n        tabID: getUniqueID(),\n      });\n    },\n  };\n\n  initChildId() {\n    this.children.forEach((item, index) => {\n      item.setId(`${this.data.tabID}_panel_${index}`);\n    });\n  }\n\n  methods = {\n    updateTabs(cb) {\n      const { children } = this;\n      const tabs = children.map((child: any) => child.data);\n\n      tabs.forEach((item) => {\n        if (typeof item.icon === 'string') {\n          item.icon = { name: item.icon };\n        }\n      });\n\n      this.setData({ tabs }, cb);\n      this.setCurrentIndexByName(this.properties.value);\n    },\n\n    setCurrentIndexByName(name) {\n      const { children } = this;\n      const index = children.findIndex((child: any) => child.getComputedName() === `${name}`);\n      if (index > -1) {\n        this.setCurrentIndex(index);\n      }\n    },\n\n    setCurrentIndex(index: number) {\n      if (index <= -1 || index >= this.children.length) return;\n      this.children.forEach((child: any, idx: number) => {\n        const isActive = index === idx;\n        if (isActive !== child.data.active) {\n          child.render(isActive, this);\n        }\n      });\n      if (this.data.currentIndex === index) return;\n      this.setData({\n        currentIndex: index,\n      });\n      this.setTrack();\n    },\n\n    getCurrentName() {\n      if (this.children) {\n        const activeTab = this.children[this.data.currentIndex];\n        if (activeTab) {\n          return activeTab.getComputedName();\n        }\n      }\n    },\n\n    calcScrollOffset(containerWidth: number, targetLeft: number, targetWidth: number, offset: number) {\n      return offset + targetLeft - (1 / 2) * containerWidth + targetWidth / 2;\n    },\n\n    getTrackSize() {\n      return new Promise<number>((resolve) => {\n        if (this.trackWidth) {\n          resolve(this.trackWidth);\n          return;\n        }\n        getRect(this, `.${prefix}-tabs__track`).then((res) => {\n          if (res) {\n            this.trackWidth = res.width;\n            resolve(this.trackWidth);\n          }\n        });\n      });\n    },\n\n    async setTrack() {\n      if (!this.properties.showBottomLine) return;\n      const { children } = this;\n      if (!children) return;\n      const { currentIndex, isScrollX, direction } = this.data;\n      if (currentIndex <= -1) return;\n\n      try {\n        const res = await getRect(this, `.${prefix}-tabs__item`, true);\n        const rect = res[currentIndex];\n        if (!rect) return;\n        let count = 0;\n        let distance = 0;\n        let totalSize = 0;\n\n        res.forEach((item) => {\n          if (count < currentIndex) {\n            distance += isScrollX ? item.width : item.height;\n            count += 1;\n          }\n          totalSize += isScrollX ? item.width : item.height;\n        });\n\n        if (this.containerWidth) {\n          const offset = this.calcScrollOffset(this.containerWidth, rect.left, rect.width, this.data.offset);\n          const maxOffset = totalSize - this.containerWidth;\n          this.setData({\n            offset: Math.min(Math.max(offset, 0), maxOffset),\n          });\n        }\n\n        if (isScrollX) {\n          const trackLineWidth = await this.getTrackSize();\n          distance += (rect.width - trackLineWidth) / 2;\n        }\n        let trackStyle = `-webkit-transform: translate${direction}(${distance}px);\n          transform: translate${direction}(${distance}px);\n        `;\n        if (!isScrollX) {\n          trackStyle += `height: ${rect.height}px;`;\n        }\n        this.setData({\n          trackStyle,\n        });\n      } catch (err) {\n        this.triggerEvent('error', err);\n      }\n    },\n\n    onTabTap(event: any) {\n      const { index } = event.currentTarget.dataset;\n\n      this.changeIndex(index);\n    },\n\n    onTouchStart(event: any) {\n      if (!this.properties.swipeable) return;\n\n      this.touchStart(event);\n    },\n\n    onTouchMove(event: any) {\n      if (!this.properties.swipeable) return;\n\n      this.touchMove(event);\n    },\n\n    onTouchEnd() {\n      if (!this.properties.swipeable) return;\n\n      const { direction, deltaX, offsetX } = this;\n      const minSwipeDistance = 50;\n      if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n        const index = this.getAvailableTabIndex(deltaX);\n        if (index !== -1) {\n          this.changeIndex(index);\n        }\n      }\n    },\n\n    onTouchScroll(event: WechatMiniprogram.CustomEvent) {\n      this._trigger('scroll', event.detail);\n    },\n\n    changeIndex(index) {\n      const currentTab = this.data.tabs[index];\n      const { value, label } = currentTab;\n      if (!currentTab?.disabled && index !== this.data.currentIndex) {\n        this._trigger('change', { value, label });\n      }\n      this._trigger('click', { value, label });\n    },\n\n    getAvailableTabIndex(deltaX: number) {\n      const step = deltaX > 0 ? -1 : 1;\n      const { currentIndex, tabs } = this.data;\n      const len = tabs.length;\n      for (let i = step; currentIndex + step >= 0 && currentIndex + step < len; i += step) {\n        const newIndex = currentIndex + i;\n        if (newIndex >= 0 && newIndex < len && tabs[newIndex] && !tabs[newIndex].disabled) {\n          return newIndex;\n        }\n      }\n      return -1;\n    },\n  };\n}\n"]}