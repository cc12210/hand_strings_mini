{"version":3,"sources":["../../src/indexes/indexes.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gBAAgB,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AAUpF,MAAM,CAAC,OAAO,OAAO,OAAQ,SAAQ,cAAc;IACjD,eAAe,WAAkF;IAEjG,UAAU,kCAAS;IAEnB,IAAI;;;;;;;;MAQF;IAEF,SAAS,EAAE,gBAAgB,CAIzB;IAEF,SAAS,WAIP;IAEF,KAAK,MAAQ;IAEb,QAAQ,QAAM;IAEd,OAAO,MAAQ;IAEf,SAAS;;;MAOP;IAEF,SAAS;;MASP;IAEF,OAAO;0BACa,MAAM,GAAG,MAAM;;;;;yBAoEhB,OAAO;;;;;;;qCA4EK,MAAM;;;;MAyDnC;CACH","file":"indexes.d.ts","sourcesContent":["import { RelationsOptions, SuperComponent, wxComponent } from '../common/src/index';\nimport config from '../common/config';\nimport props from './props';\nimport { getRect, throttle } from '../common/utils';\nimport pageScrollMixin from '../mixins/page-scroll';\n\nconst { prefix } = config;\nconst name = `${prefix}-indexes`;\n\n@wxComponent()\nexport default class Indexes extends SuperComponent {\n  externalClasses = [`${prefix}-class`, `${prefix}-class-sidebar`, `${prefix}-class-sidebar-item`];\n\n  properties = props;\n\n  data = {\n    prefix,\n    classPrefix: name,\n    _height: 0,\n    _indexList: [],\n    scrollTop: 0,\n    activeAnchor: null,\n    showTips: false,\n  };\n\n  relations: RelationsOptions = {\n    '../indexes-anchor/indexes-anchor': {\n      type: 'child',\n    },\n  };\n\n  behaviors = [\n    pageScrollMixin(function (event) {\n      this.onScroll(event);\n    }),\n  ];\n\n  timer = null;\n\n  groupTop = [];\n\n  sidebar = null;\n\n  observers = {\n    indexList(v) {\n      this.setIndexList(v);\n    },\n    height(v) {\n      this.setHeight(v);\n    },\n  };\n\n  lifetimes = {\n    ready() {\n      if (this.data._height === 0) {\n        this.setHeight();\n      }\n      if (this.data._indexList?.length === 0) {\n        this.setIndexList();\n      }\n    },\n  };\n\n  methods = {\n    setHeight(height: string | number) {\n      if (!height) {\n        const { windowHeight } = wx.getSystemInfoSync();\n        height = windowHeight;\n      }\n      this.setData(\n        {\n          _height: height,\n        },\n        () => {\n          this.getAllRect();\n        },\n      );\n    },\n\n    setIndexList(list) {\n      if (!list) {\n        const start = 'A'.charCodeAt(0);\n        const alphabet = [];\n\n        for (let i = start, end = start + 26; i < end; i += 1) {\n          alphabet.push(String.fromCharCode(i));\n        }\n\n        this.setData({ _indexList: alphabet });\n      } else {\n        this.setData({ _indexList: list });\n      }\n    },\n\n    getAllRect() {\n      this.getAnchorsRect().then(() => {\n        this.groupTop.forEach((item, index) => {\n          const next = this.groupTop[index + 1];\n          item.totalHeight = (next?.top || Infinity) - item.top;\n        });\n        this.setAnchorOnScroll(0);\n      });\n      this.getSidebarRect();\n    },\n\n    getAnchorsRect() {\n      return Promise.all(\n        this.$children.map((child) =>\n          getRect(child, `.${name}-anchor`).then((rect) => {\n            this.groupTop.push({\n              height: rect.height,\n              top: rect.top,\n              anchor: child.data.index,\n            });\n          }),\n        ),\n      );\n    },\n\n    getSidebarRect() {\n      getRect(this, `#id-${name}__bar`).then((rect) => {\n        const { top, height } = rect;\n        const { length } = this.data._indexList;\n\n        this.sidebar = {\n          top,\n          height,\n          itemHeight: (height - (length - 1) * 2) / length, // margin = 2px\n        };\n      });\n    },\n\n    toggleTips(flag: boolean) {\n      if (!flag) {\n        clearInterval(this.timer);\n        this.timer = setTimeout(() => {\n          this.setData({\n            showTips: false,\n          });\n        }, 300);\n      } else {\n        this.setData({\n          showTips: true,\n        });\n      }\n    },\n\n    setAnchorByIndex(index) {\n      if (this.preIndex != null && this.preIndex === index) return;\n\n      const { _indexList } = this.data;\n      const activeAnchor = _indexList[index];\n      const target = this.groupTop.find((item) => item.anchor === activeAnchor);\n\n      if (target) {\n        wx.pageScrollTo({\n          scrollTop: target.top,\n          duration: 0,\n        });\n      }\n\n      this.preIndex = index;\n      this.toggleTips(true);\n      this.triggerEvent('select', { index: activeAnchor });\n\n      if (activeAnchor !== this.data.activeAnchor) {\n        this.triggerEvent('change', { index: activeAnchor });\n      }\n    },\n\n    onClick(e) {\n      const { index } = e.currentTarget.dataset;\n\n      this.setAnchorByIndex(index);\n    },\n\n    onTouchMove(e) {\n      this.onAnchorTouch(e);\n    },\n\n    onTouchCancel() {\n      this.toggleTips(false);\n    },\n\n    onTouchEnd(e) {\n      this.toggleTips(false);\n      this.onAnchorTouch(e);\n    },\n\n    onAnchorTouch: throttle(function (e: WechatMiniprogram.TouchEvent) {\n      const getAnchorIndex = (clientY) => {\n        const offsetY = clientY - this.sidebar.top;\n\n        if (offsetY <= 0) {\n          return 0;\n        }\n\n        if (offsetY > this.sidebar.height) {\n          return this.data._indexList.length - 1;\n        }\n\n        return Math.floor(offsetY / this.sidebar.itemHeight);\n      };\n      const index = getAnchorIndex(e.changedTouches[0].clientY);\n\n      this.setAnchorByIndex(index);\n    }, 1000 / 30), // 30 frame\n\n    setAnchorOnScroll(scrollTop: number) {\n      if (!this.groupTop) {\n        return;\n      }\n\n      const { sticky, stickyOffset } = this.data;\n\n      scrollTop += stickyOffset;\n\n      const curIndex = this.groupTop.findIndex(\n        (group) => scrollTop >= group.top - group.height && scrollTop <= group.top + group.totalHeight - group.height,\n      );\n\n      if (curIndex === -1) return;\n\n      const curGroup = this.groupTop[curIndex];\n\n      if (this.data.activeAnchor !== curGroup.anchor) {\n        this.triggerEvent('change', { index: curGroup.anchor });\n      }\n\n      this.setData({\n        activeAnchor: curGroup.anchor,\n      });\n\n      if (sticky) {\n        const offset = curGroup.top - scrollTop;\n        const betwixt = offset < curGroup.height && offset > 0 && scrollTop > stickyOffset;\n\n        this.$children.forEach((child, index) => {\n          if (index === curIndex) {\n            child.setData({\n              sticky: scrollTop > stickyOffset,\n              active: true,\n              style: `height: ${curGroup.height}px`,\n              anchorStyle: `transform: translate3d(0, ${betwixt ? offset : 0}px, 0); top: ${stickyOffset}px`,\n            });\n          } else if (index + 1 === curIndex) {\n            // 两个 anchor 同时出现时的上一个\n            child.setData({\n              sticky: true,\n              active: true,\n              style: `height: ${curGroup.height}px`,\n              anchorStyle: `transform: translate3d(0, ${\n                betwixt ? offset - curGroup.height : 0\n              }px, 0); top: ${stickyOffset}px`,\n            });\n          } else {\n            child.setData({ active: false, sticky: false, anchorStyle: '' });\n          }\n        });\n      }\n    },\n\n    onScroll({ scrollTop }) {\n      this.setAnchorOnScroll(scrollTop);\n    },\n  };\n}\n"]}