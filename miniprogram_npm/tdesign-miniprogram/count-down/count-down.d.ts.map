{"version":3,"sources":["../../src/count-down/count-down.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AASlE,MAAM,CAAC,OAAO,OAAO,SAAU,SAAQ,cAAc;IACnD,eAAe,WAAyE;IAExF,UAAU,oCAAS;IAEnB,SAAS;;MAIP;IAEF,IAAI;;;;;;;;;;;;MAMF;IAEF,SAAS,EAAE,IAAI,GAAG,MAAM,CAAQ;IAEhC,SAAS;;MAOP;IAEF,OAAO;;;;mBA0BM,MAAM;2BAIE,MAAM;;MAkCzB;CACH","file":"count-down.d.ts","sourcesContent":["import { SuperComponent, wxComponent } from '../common/src/index';\nimport config from '../common/config';\nimport props from './props';\nimport { isSameSecond, parseFormat, parseTimeData, TimeDataUnit } from './utils';\n\nconst { prefix } = config;\nconst name = `${prefix}-count-down`;\n\n@wxComponent()\nexport default class CountDown extends SuperComponent {\n  externalClasses = [`${prefix}-class`, `${prefix}-class-count`, `${prefix}-class-split`];\n\n  properties = props;\n\n  observers = {\n    time() {\n      this.reset();\n    },\n  };\n\n  data = {\n    prefix,\n    classPrefix: name,\n    timeDataUnit: TimeDataUnit,\n    timeData: parseTimeData(0),\n    formattedTime: '0',\n  };\n\n  timeoutId: null | number = null;\n\n  lifetimes = {\n    detached() {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n    },\n  };\n\n  methods = {\n    start() {\n      if (this.counting) {\n        return;\n      }\n\n      this.counting = true;\n      this.endTime = Date.now() + this.remain;\n      this.doCount();\n    },\n\n    pause() {\n      this.counting = false;\n      this.timeoutId && clearTimeout(this.timeoutId);\n    },\n\n    reset() {\n      this.pause();\n      this.remain = this.properties.time;\n      this.updateTime(this.remain);\n\n      if (this.properties.autoStart) {\n        this.start();\n      }\n    },\n\n    getTime(): number {\n      return Math.max(this.endTime - Date.now(), 0);\n    },\n\n    updateTime(remain: number) {\n      const { format } = this.properties;\n      this.remain = remain;\n      const timeData = parseTimeData(remain);\n      this.triggerEvent('change', timeData);\n      const { timeText } = parseFormat(remain, format as any as string);\n      const timeRange = format.split(':');\n      this.setData({\n        timeRange,\n        timeData,\n        formattedTime: timeText.replace(/:/g, ' : '),\n      });\n\n      if (remain === 0) {\n        this.pause();\n        this.triggerEvent('finish');\n      }\n    },\n\n    doCount() {\n      this.timeoutId = setTimeout(() => {\n        const time = this.getTime();\n\n        if (this.properties.millisecond) {\n          this.updateTime(time);\n        } else if (!isSameSecond(time, this.remain) || time === 0) {\n          this.updateTime(time);\n        }\n\n        if (time !== 0) {\n          this.doCount();\n        }\n      }, 33); // 30 帧，因此 1000 / 30 = 33\n    },\n  };\n}\n"]}