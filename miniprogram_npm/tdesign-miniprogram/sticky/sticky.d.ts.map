{"version":3,"sources":["../../src/sticky/sticky.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAe,MAAM,qBAAqB,CAAC;AAGlE,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAS5C,MAAM,WAAW,WAAY,SAAQ,aAAa;CAAG;AAGrD,MAAM,CAAC,OAAO,OAAO,MAAO,SAAQ,cAAc;IAChD,eAAe,WAAuB;IAEtC,UAAU,gBAAS;IAEnB,SAAS,WAIP;IAEF,SAAS;;MAIP;IAEF,IAAI;;;;;MAKF;IAEF,KAAK;IAIL,OAAO;yBACY;YAAE,SAAS,EAAE,MAAM,CAAA;SAAE;+BA+Cf;YAAE,OAAO,EAAE,OAAO,CAAC;YAAC,MAAM,CAAC,EAAE,MAAM,CAAC;YAAC,SAAS,CAAC,EAAE,MAAM,CAAA;SAAE;;MAkChF;CACH","file":"sticky.d.ts","sourcesContent":["import { SuperComponent, wxComponent } from '../common/src/index';\nimport props from './props';\nimport config from '../common/config';\nimport type { TdStickyProps } from './type';\nimport pageScrollMixin from '../mixins/page-scroll';\nimport { getRect } from '../common/utils';\n\nconst { prefix } = config;\nconst name = `${prefix}-sticky`;\n\nconst ContainerClass = `.${name}`;\n\nexport interface StickyProps extends TdStickyProps {}\n\n@wxComponent()\nexport default class Sticky extends SuperComponent {\n  externalClasses = [`${prefix}-class`];\n\n  properties = props;\n\n  behaviors = [\n    pageScrollMixin(function (event) {\n      this.onScroll(event);\n    }),\n  ];\n\n  observers = {\n    'offsetTop, disabled, container'() {\n      this.onScroll();\n    },\n  };\n\n  data = {\n    prefix,\n    classPrefix: name,\n    containerStyle: '',\n    contentStyle: '',\n  };\n\n  ready() {\n    this.onScroll();\n  }\n\n  methods = {\n    onScroll(event?: { scrollTop: number }) {\n      const { scrollTop } = event || {};\n      const { container, offsetTop, disabled } = this.properties;\n\n      if (disabled) {\n        this.setDataAfterDiff({\n          isFixed: false,\n          transform: 0,\n        });\n        return;\n      }\n\n      this.scrollTop = scrollTop || this.scrollTop;\n\n      if (typeof container === 'function') {\n        Promise.all([getRect(this, ContainerClass), this.getContainerRect()]).then(([root, container]) => {\n          if (!root || !container) return;\n          if (offsetTop + root.height > container.height + container.top) {\n            this.setDataAfterDiff({\n              isFixed: false,\n              transform: container.height - root.height,\n            });\n          } else if (offsetTop >= root.top) {\n            this.setDataAfterDiff({\n              isFixed: true,\n              height: root.height,\n              transform: 0,\n            });\n          } else {\n            this.setDataAfterDiff({ isFixed: false, transform: 0 });\n          }\n        });\n\n        return;\n      }\n\n      getRect(this, ContainerClass).then((root) => {\n        if (!root) return;\n        if (offsetTop >= root.top) {\n          this.setDataAfterDiff({ isFixed: true, height: root.height });\n          this.transform = 0;\n        } else {\n          this.setDataAfterDiff({ isFixed: false });\n        }\n      });\n    },\n\n    setDataAfterDiff(data: { isFixed: boolean; height?: number; transform?: number }) {\n      const { offsetTop } = this.properties;\n      const { containerStyle: prevContainerStyle, contentStyle: prevContentStyle } = this.data;\n      const { isFixed, height, transform } = data;\n      wx.nextTick(() => {\n        let containerStyle = '';\n        let contentStyle = '';\n\n        if (isFixed) {\n          containerStyle += `height:${height}px;`;\n          contentStyle += `position:fixed;top:${offsetTop}px;`;\n        }\n        if (transform) {\n          const translate = `translate3d(0, ${transform}px, 0)`;\n          contentStyle += `-webkit-transform:${translate};transform:${translate};`;\n        }\n\n        if (prevContainerStyle !== containerStyle || prevContentStyle !== contentStyle) {\n          this.setData({ containerStyle, contentStyle });\n        }\n\n        this.triggerEvent('scroll', {\n          scrollTop: this.scrollTop,\n          isFixed,\n        });\n      });\n    },\n\n    getContainerRect() {\n      const nodesRef: WechatMiniprogram.NodesRef = this.properties.container();\n      return new Promise<WechatMiniprogram.BoundingClientRectCallbackResult>((resolve) =>\n        nodesRef.boundingClientRect(resolve).exec(),\n      );\n    },\n  };\n}\n"]}