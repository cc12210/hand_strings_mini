{"version":3,"sources":["../../src/common/utils.ts"],"names":[],"mappings":";;AAIA,aAAK,OAAO,GAAG,iBAAiB,CAAC,IAAI,CAAC,eAAe,GAAG,iBAAiB,CAAC,SAAS,CAAC,eAAe,CAAC;AAEpG,eAAO,MAAM,QAAQ,wDAUpB,CAAC;AAEF,eAAO,MAAM,QAAQ,uEA2BpB,CAAC;AAEF,eAAO,MAAM,UAAU,4BA8BtB,CAAC;AAEF,eAAO,MAAM,MAAM,2BAIlB,CAAC;AAEF,eAAO,MAAM,iBAAiB,OAAiB,QAAQ,+BAQtD,CAAC;AAEF,eAAO,MAAM,OAAO,YAAsB,GAAG,YAAY,MAAM,YAAW,OAAO,iBAchF,CAAC;AAMF,eAAO,MAAM,QAAQ,yBAEpB,CAAC;AAEF,eAAO,MAAM,OAAO,WAAqB,MAAM,GAAG,MAAM,KAAG,MAAM,GAAG,SAMnE,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,kBAAkB,SAAU,MAAM,OAAO,MAAM,QAAQ,MAAM;;;CAyCzE,CAAC;AAEF,eAAO,MAAM,KAAK,QAAS,GAAG,EAAE,QAAQ,MAAM,YACwD,CAAC;AAEvG,eAAO,MAAM,WAAW,aAAuB,OAAO,aAAa,MAAM,gDAYxE,CAAC;AAEF,eAAO,MAAM,WAAW,UAAW,MAAM,GAAG,MAAM,KAAG,MAQpD,CAAC;AAEF,eAAO,MAAM,OAAO;;CAuBnB,CAAC;AAEF,eAAO,MAAM,MAAM,uBAAoC,CAAC;AAExD,eAAO,MAAM,QAAQ,uBAAkD,CAAC;AAExE,eAAO,MAAM,QAAQ,uBAAmC,CAAC;AAEzD,eAAO,MAAM,OAAO,mBAAkE,CAAC;AAEvF,eAAO,MAAM,cAAc,kSAG1B,CAAC;AAEF,eAAO,MAAM,aAAa,iCAGzB,CAAC;AAEF,eAAO,MAAM,QAAQ,SAAU,MAAM,GAAG,OAAO,MAAM,EAAE,GAAG,CAAC,gBAAgB,MAAM,iCAQhF,CAAC","file":"utils.d.ts","sourcesContent":["import { prefix } from './config';\n\nconst systemInfo = wx.getSystemInfoSync();\n\ntype Context = WechatMiniprogram.Page.TrivialInstance | WechatMiniprogram.Component.TrivialInstance;\n\nexport const debounce = function (func, wait = 500) {\n  let timerId;\n  return function (...rest) {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(() => {\n      func.apply(this, rest);\n    }, wait);\n  };\n};\n\nexport const throttle = (func, wait = 100, options = null) => {\n  let previous = 0;\n  let timerid = null;\n\n  if (!options) {\n    options = {\n      leading: true,\n    };\n  }\n\n  return function (...args) {\n    const now = Date.now();\n\n    if (!previous && !options.leading) previous = now;\n\n    const remaining = wait - (now - previous);\n    const context = this;\n\n    if (remaining <= 0) {\n      if (timerid) {\n        clearTimeout(timerid);\n        timerid = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    }\n  };\n};\n\nexport const classNames = function (...args) {\n  const hasOwn = {}.hasOwnProperty;\n  const classes = [];\n\n  args.forEach((arg) => {\n    // for (let i = 0; i < args.length; i++) {\n    // eslint-disable-next-line\n    // const arg = args[i]\n    if (!arg) return;\n\n    const argType = typeof arg;\n\n    if (argType === 'string' || argType === 'number') {\n      classes.push(arg);\n    } else if (Array.isArray(arg) && arg.length) {\n      const inner = classNames(...arg);\n      if (inner) {\n        classes.push(inner);\n      }\n    } else if (argType === 'object') {\n      // eslint-disable-next-line\n      for (const key in arg) {\n        if (hasOwn.call(arg, key) && arg[key]) {\n          classes.push(key);\n        }\n      }\n    }\n  });\n\n  return classes.join(' ');\n};\n\nexport const styles = function (styleObj) {\n  return Object.keys(styleObj)\n    .map((styleKey) => `${styleKey}: ${styleObj[styleKey]}`)\n    .join('; ');\n};\n\nexport const getAnimationFrame = function (cb: Function) {\n  return wx\n    .createSelectorQuery()\n    .selectViewport()\n    .boundingClientRect()\n    .exec(() => {\n      cb();\n    });\n};\n\nexport const getRect = function (context: any, selector: string, needAll: boolean = false) {\n  return new Promise<any>((resolve, reject) => {\n    wx.createSelectorQuery()\n      .in(context)\n      [needAll ? 'selectAll' : 'select'](selector)\n      .boundingClientRect((rect) => {\n        if (rect) {\n          resolve(rect);\n        } else {\n          reject(rect);\n        }\n      })\n      .exec();\n  });\n};\n\nconst isDef = function (value: any): boolean {\n  return value !== undefined && value !== null;\n};\n\nexport const isNumber = function (value) {\n  return /^\\d+(\\.\\d+)?$/.test(value);\n};\n\nexport const addUnit = function (value?: string | number): string | undefined {\n  if (!isDef(value)) {\n    return undefined;\n  }\n  value = String(value);\n  return isNumber(value) ? `${value}px` : value;\n};\n\n/**\n * 计算字符串字符的长度并可以截取字符串。\n * @param str 传入字符串（maxcharacter条件下，一个汉字表示两个字符）\n * @param max 规定最大字符串长度\n * @returns 当没有传入maxCharacter/maxLength 时返回字符串字符长度，当传入maxCharacter/maxLength时返回截取之后的字符串和长度。\n */\nexport const getCharacterLength = (type: string, str: string, max?: number) => {\n  if (!str || str.length === 0) {\n    return {\n      length: 0,\n      characters: '',\n    };\n  }\n\n  if (type === 'maxcharacter') {\n    let len = 0;\n    for (let i = 0; i < str.length; i += 1) {\n      let currentStringLength = 0;\n      if (str.charCodeAt(i) > 127 || str.charCodeAt(i) === 94) {\n        currentStringLength = 2;\n      } else {\n        currentStringLength = 1;\n      }\n      if (len + currentStringLength > max) {\n        return {\n          length: len,\n          characters: str.slice(0, i),\n        };\n      }\n      len += currentStringLength;\n    }\n    return {\n      length: len,\n      characters: str,\n    };\n  } else if (type === 'maxlength') {\n    const length = str.length > max ? max : str.length;\n    return {\n      length,\n      characters: str.slice(0, length),\n    };\n  }\n\n  return {\n    length: str.length,\n    characters: str,\n  };\n};\n\nexport const chunk = (arr: any[], size: number) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));\n\nexport const getInstance = function (context?: Context, selector?: string) {\n  if (!context) {\n    const pages = getCurrentPages();\n    const page = pages[pages.length - 1];\n    context = page.$$basePage || page;\n  }\n  const instance = context ? context.selectComponent(selector) : null;\n  if (!instance) {\n    console.warn('未找到组件,请检查selector是否正确');\n    return null;\n  }\n  return instance;\n};\n\nexport const unitConvert = (value: number | string): number => {\n  if (typeof value === 'string') {\n    if (value.includes('rpx')) {\n      return (parseInt(value, 10) * (systemInfo?.screenWidth ?? 750)) / 750;\n    }\n    return parseInt(value, 10);\n  }\n  return value;\n};\n\nexport const setIcon = (iconName, icon, defaultIcon) => {\n  if (icon) {\n    if (typeof icon === 'string') {\n      return {\n        [`${iconName}Name`]: icon,\n        [`${iconName}Data`]: {},\n      };\n    } else if (typeof icon === 'object') {\n      return {\n        [`${iconName}Name`]: '',\n        [`${iconName}Data`]: icon,\n      };\n    } else {\n      return {\n        [`${iconName}Name`]: defaultIcon,\n        [`${iconName}Data`]: {},\n      };\n    }\n  }\n  return {\n    [`${iconName}Name`]: '',\n    [`${iconName}Data`]: {},\n  };\n};\n\nexport const isBool = (val) => typeof val === 'boolean';\n\nexport const isObject = (val) => typeof val === 'object' && val != null;\n\nexport const isString = (val) => typeof val === 'string';\n\nexport const toCamel = (str) => str.replace(/-(\\w)/g, (match, m1) => m1.toUpperCase());\n\nexport const getCurrentPage = function <T>() {\n  const pages = getCurrentPages();\n  return pages[pages.length - 1] as T & WechatMiniprogram.Page.TrivialInstance;\n};\n\nexport const uniqueFactory = (compName) => {\n  let number = 0;\n  return () => `${prefix}_${compName}_${number++}`;\n};\n\nexport const calcIcon = (icon: string | Record<string, any>, defaultIcon?: string) => {\n  if ((isBool(icon) && icon && defaultIcon) || isString(icon)) {\n    return { name: isBool(icon) ? defaultIcon : icon };\n  }\n  if (isObject(icon)) {\n    return icon;\n  }\n  return null;\n};\n"]}