{"version":3,"sources":["../../src/notice-bar/notice-bar.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAe,qBAAqB,EAAE,MAAM,qBAAqB,CAAC;AASzF,MAAM,CAAC,OAAO,OAAO,SAAU,SAAQ,cAAc;IACnD,eAAe,WAMb;IAEF,OAAO,EAAE,qBAAqB,CAG5B;IAEF,UAAU,oCAAS;IAEnB,IAAI;;;;MAIF;IAEF,SAAS;;;;;;MAmCP;IAEF,SAAS;;;;MAeP;IAEF,OAAO;;;;QAiFL,WAAW;;;;;;;MA2BX;CACH","file":"notice-bar.d.ts","sourcesContent":["import { SuperComponent, wxComponent, ComponentsOptionsType } from '../common/src/index';\nimport { getRect, getAnimationFrame, calcIcon } from '../common/utils';\nimport props from './props';\nimport config from '../common/config';\n\nconst { prefix } = config;\nconst name = `${prefix}-notice-bar`;\n\n@wxComponent()\nexport default class NoticeBar extends SuperComponent {\n  externalClasses = [\n    `${prefix}-class`,\n    `${prefix}-class-content`,\n    `${prefix}-class-prefix-icon`,\n    `${prefix}-class-extra`,\n    `${prefix}-class-suffix-icon`,\n  ];\n\n  options: ComponentsOptionsType = {\n    styleIsolation: 'apply-shared',\n    multipleSlots: true,\n  };\n\n  properties = props;\n\n  data = {\n    prefix,\n    classPrefix: name,\n    loop: -1,\n  };\n\n  observers = {\n    marquee(val) {\n      if (JSON.stringify(val) === '{}' || JSON.stringify(val) === 'true') {\n        this.setData({\n          marquee: {\n            speed: 50,\n            loop: -1,\n            delay: 0,\n          },\n        });\n      }\n    },\n\n    visible(visible) {\n      if (visible) {\n        this.show();\n      } else {\n        this.clearNoticeBarAnimation();\n      }\n    },\n\n    prefixIcon(prefixIcon) {\n      this.setPrefixIcon(prefixIcon);\n    },\n\n    suffixIcon(v) {\n      this.setData({\n        _suffixIcon: calcIcon(v),\n      });\n    },\n\n    content() {\n      this.clearNoticeBarAnimation();\n      this.initAnimation();\n    },\n  };\n\n  lifetimes = {\n    created() {\n      this.resetAnimation = wx.createAnimation({\n        duration: 0,\n        timingFunction: 'linear',\n      });\n    },\n\n    detached() {\n      this.clearNoticeBarAnimation();\n    },\n\n    ready() {\n      this.show();\n    },\n  };\n\n  methods = {\n    initAnimation() {\n      // 获取外部容器和滚动内容的宽度\n      const warpID = `.${name}__content-wrap`;\n      const nodeID = `.${name}__content`;\n      getAnimationFrame(() => {\n        Promise.all([getRect(this, nodeID), getRect(this, warpID)]).then(([nodeRect, wrapRect]) => {\n          const { marquee } = this.properties;\n\n          if (nodeRect == null || wrapRect == null || !nodeRect.width || !wrapRect.width) {\n            return;\n          }\n\n          if (marquee || wrapRect.width < nodeRect.width) {\n            const speeding = marquee.speed || 50;\n            const delaying = marquee.delay || 0;\n            const loops = marquee.loop - 1 || -1;\n            const animationDuration = ((wrapRect.width + nodeRect.width) / speeding) * 1000;\n            const firstAnimationDuration = (nodeRect.width / speeding) * 1000;\n\n            this.setData({\n              wrapWidth: Number(wrapRect.width),\n              nodeWidth: Number(nodeRect.width),\n              animationDuration: animationDuration,\n              delay: delaying,\n              loop: loops,\n              firstAnimationDuration: firstAnimationDuration,\n            });\n\n            this.startScrollAnimation(true);\n          }\n        });\n      });\n    },\n\n    startScrollAnimation(isFirstScroll = false) {\n      this.clearNoticeBarAnimation();\n\n      const { wrapWidth, nodeWidth, firstAnimationDuration, animationDuration, delay } = this.data;\n      const delayTime = isFirstScroll ? delay : 0;\n      const durationTime = isFirstScroll ? firstAnimationDuration : animationDuration;\n\n      // 滚动内容: 初始位置\n      this.setData({\n        animationData: this.resetAnimation\n          .translateX(isFirstScroll ? 0 : wrapWidth)\n          .step()\n          .export(),\n      });\n\n      getAnimationFrame(() => {\n        // 滚动内容: 最终位置\n        this.setData({\n          animationData: wx\n            .createAnimation({ duration: durationTime, timingFunction: 'linear', delay: delayTime })\n            .translateX(-nodeWidth)\n            .step()\n            .export(),\n        });\n      });\n\n      // 滚动一次完成, 开启下一次的滚动\n      this.nextAnimationContext = setTimeout(() => {\n        if (this.data.loop > 0) {\n          this.data.loop -= 1;\n          this.startScrollAnimation();\n        } else if (this.data.loop === 0) {\n          // 动画回到初始位置\n          this.setData({ animationData: this.resetAnimation.translateX(0).step().export() });\n        } else if (this.data.loop < 0) {\n          this.startScrollAnimation();\n        }\n      }, durationTime + delayTime);\n    },\n\n    show() {\n      this.clearNoticeBarAnimation();\n      this.setPrefixIcon(this.properties.prefixIcon);\n      this.initAnimation();\n    },\n\n    /** 清除动画 */\n    clearNoticeBarAnimation() {\n      this.nextAnimationContext && clearTimeout(this.nextAnimationContext);\n      this.nextAnimationContext = null;\n    },\n\n    setPrefixIcon(v) {\n      this.setData({\n        _prefixIcon: calcIcon(v, 'error-circle-filled'),\n      });\n    },\n\n    clickPrefixIcon() {\n      this.triggerEvent('click', { trigger: 'prefix-icon' });\n    },\n\n    clickContent() {\n      this.triggerEvent('click', { trigger: 'content' });\n    },\n\n    clickSuffixIcon() {\n      this.triggerEvent('click', { trigger: 'suffix-icon' });\n    },\n\n    clickExtra() {\n      this.triggerEvent('click', { trigger: 'extra' });\n    },\n  };\n}\n"]}